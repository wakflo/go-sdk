// Code generated by "go-enumer (github.com/mvrahden/go-enumer)"; DO NOT EDIT.

package connectorenums

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strconv"
)

var (
	ErrNoValidEnum = errors.New("not a valid enum")
)

const (
	_ConnectorPlatformString      = "nativeplugin"
	_ConnectorPlatformLowerString = "nativeplugin"
)

var (
	_ConnectorPlatformValues  = [2]ConnectorPlatform{0, 1}
	_ConnectorPlatformStrings = [2]string{_ConnectorPlatformString[0:6], _ConnectorPlatformString[6:12]}
)

// _ConnectorPlatformNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of ConnectorPlatform.
func _ConnectorPlatformNoOp() {
	var x [1]struct{}
	_ = x[Native-(0)]
	_ = x[Plugin-(1)]
}

// ConnectorPlatformValues returns all values of the enum.
func ConnectorPlatformValues() []ConnectorPlatform {
	cp := _ConnectorPlatformValues
	return cp[:]
}

// ConnectorPlatformStrings returns a slice of all String values of the enum.
func ConnectorPlatformStrings() []string {
	cp := _ConnectorPlatformStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_c ConnectorPlatform) IsValid() bool {
	return _c >= 0 && _c <= 1
}

// Validate whether the value is within the range of enum values.
func (_c ConnectorPlatform) Validate() error {
	if !_c.IsValid() {
		return fmt.Errorf("ConnectorPlatform(%d) is %w", _c, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern ConnectorPlatform(%d) instead.
func (_c ConnectorPlatform) String() string {
	if !_c.IsValid() {
		return fmt.Sprintf("ConnectorPlatform(%d)", _c)
	}
	idx := uint(_c)
	return _ConnectorPlatformStrings[idx]
}

var (
	_ConnectorPlatformStringToValueMap = map[string]ConnectorPlatform{
		_ConnectorPlatformString[0:6]:  Native,
		_ConnectorPlatformString[6:12]: Plugin,
	}
	_ConnectorPlatformLowerStringToValueMap = map[string]ConnectorPlatform{
		_ConnectorPlatformLowerString[0:6]:  Native,
		_ConnectorPlatformLowerString[6:12]: Plugin,
	}
)

// ConnectorPlatformFromString determines the enum value with an exact case match.
func ConnectorPlatformFromString(raw string) (ConnectorPlatform, bool) {
	v, ok := _ConnectorPlatformStringToValueMap[raw]
	if !ok {
		return ConnectorPlatform(0), false
	}
	return v, true
}

// ConnectorPlatformFromStringIgnoreCase determines the enum value with a case-insensitive match.
func ConnectorPlatformFromStringIgnoreCase(raw string) (ConnectorPlatform, bool) {
	v, ok := ConnectorPlatformFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _ConnectorPlatformLowerStringToValueMap[raw]
	if !ok {
		return ConnectorPlatform(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for ConnectorPlatform.
func (_c ConnectorPlatform) MarshalBinary() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorPlatform. %w", _c, err)
	}
	return []byte(_c.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for ConnectorPlatform.
func (_c *ConnectorPlatform) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("ConnectorPlatform cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorPlatformFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorPlatform", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for ConnectorPlatform.
func (_c ConnectorPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_c.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for ConnectorPlatform.
func (_c *ConnectorPlatform) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of ConnectorPlatform: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorPlatform cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorPlatformFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorPlatform", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for ConnectorPlatform.
func (_c ConnectorPlatform) MarshalJSON() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorPlatform. %w", _c, err)
	}
	return json.Marshal(_c.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for ConnectorPlatform.
func (_c *ConnectorPlatform) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("ConnectorPlatform should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorPlatform cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorPlatformFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorPlatform", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for ConnectorPlatform.
func (_c ConnectorPlatform) Value() (driver.Value, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as ConnectorPlatform. %w", _c, err)
	}
	return _c.String(), nil
}

// Scan implements the sql/driver.Scanner interface for ConnectorPlatform.
func (_c *ConnectorPlatform) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of ConnectorPlatform: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorPlatform cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorPlatformFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorPlatform", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for ConnectorPlatform.
func (_c ConnectorPlatform) MarshalText() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorPlatform. %w", _c, err)
	}
	return []byte(_c.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ConnectorPlatform.
func (_c *ConnectorPlatform) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("ConnectorPlatform cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorPlatformFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorPlatform", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for ConnectorPlatform.
func (_c ConnectorPlatform) MarshalYAML() (interface{}, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorPlatform. %w", _c, err)
	}
	return _c.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for ConnectorPlatform.
func (_c *ConnectorPlatform) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	if err := unmarshal(&str); err != nil {
		return err
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorPlatform cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorPlatformFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorPlatform", str)
	}
	return nil
}

// Values returns a slice of all String values of the enum.
func (ConnectorPlatform) Values() []string {
	return ConnectorPlatformStrings()
}

const (
	_ConnectorSchemaVersionString      = "v1"
	_ConnectorSchemaVersionLowerString = "v1"
)

var (
	_ConnectorSchemaVersionValues  = [1]ConnectorSchemaVersion{0}
	_ConnectorSchemaVersionStrings = [1]string{_ConnectorSchemaVersionString[0:2]}
)

// _ConnectorSchemaVersionNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of ConnectorSchemaVersion.
func _ConnectorSchemaVersionNoOp() {
	var x [1]struct{}
	_ = x[V1-(0)]
}

// ConnectorSchemaVersionValues returns all values of the enum.
func ConnectorSchemaVersionValues() []ConnectorSchemaVersion {
	cp := _ConnectorSchemaVersionValues
	return cp[:]
}

// ConnectorSchemaVersionStrings returns a slice of all String values of the enum.
func ConnectorSchemaVersionStrings() []string {
	cp := _ConnectorSchemaVersionStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_c ConnectorSchemaVersion) IsValid() bool {
	return _c >= 0 && _c <= 0
}

// Validate whether the value is within the range of enum values.
func (_c ConnectorSchemaVersion) Validate() error {
	if !_c.IsValid() {
		return fmt.Errorf("ConnectorSchemaVersion(%d) is %w", _c, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern ConnectorSchemaVersion(%d) instead.
func (_c ConnectorSchemaVersion) String() string {
	if !_c.IsValid() {
		return fmt.Sprintf("ConnectorSchemaVersion(%d)", _c)
	}
	idx := uint(_c)
	return _ConnectorSchemaVersionStrings[idx]
}

var (
	_ConnectorSchemaVersionStringToValueMap = map[string]ConnectorSchemaVersion{
		_ConnectorSchemaVersionString[0:2]: V1,
	}
	_ConnectorSchemaVersionLowerStringToValueMap = map[string]ConnectorSchemaVersion{
		_ConnectorSchemaVersionLowerString[0:2]: V1,
	}
)

// ConnectorSchemaVersionFromString determines the enum value with an exact case match.
func ConnectorSchemaVersionFromString(raw string) (ConnectorSchemaVersion, bool) {
	v, ok := _ConnectorSchemaVersionStringToValueMap[raw]
	if !ok {
		return ConnectorSchemaVersion(0), false
	}
	return v, true
}

// ConnectorSchemaVersionFromStringIgnoreCase determines the enum value with a case-insensitive match.
func ConnectorSchemaVersionFromStringIgnoreCase(raw string) (ConnectorSchemaVersion, bool) {
	v, ok := ConnectorSchemaVersionFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _ConnectorSchemaVersionLowerStringToValueMap[raw]
	if !ok {
		return ConnectorSchemaVersion(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for ConnectorSchemaVersion.
func (_c ConnectorSchemaVersion) MarshalBinary() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorSchemaVersion. %w", _c, err)
	}
	return []byte(_c.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for ConnectorSchemaVersion.
func (_c *ConnectorSchemaVersion) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("ConnectorSchemaVersion cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorSchemaVersionFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorSchemaVersion", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for ConnectorSchemaVersion.
func (_c ConnectorSchemaVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_c.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for ConnectorSchemaVersion.
func (_c *ConnectorSchemaVersion) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of ConnectorSchemaVersion: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorSchemaVersion cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorSchemaVersionFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorSchemaVersion", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for ConnectorSchemaVersion.
func (_c ConnectorSchemaVersion) MarshalJSON() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorSchemaVersion. %w", _c, err)
	}
	return json.Marshal(_c.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for ConnectorSchemaVersion.
func (_c *ConnectorSchemaVersion) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("ConnectorSchemaVersion should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorSchemaVersion cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorSchemaVersionFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorSchemaVersion", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for ConnectorSchemaVersion.
func (_c ConnectorSchemaVersion) Value() (driver.Value, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as ConnectorSchemaVersion. %w", _c, err)
	}
	return _c.String(), nil
}

// Scan implements the sql/driver.Scanner interface for ConnectorSchemaVersion.
func (_c *ConnectorSchemaVersion) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of ConnectorSchemaVersion: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorSchemaVersion cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorSchemaVersionFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorSchemaVersion", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for ConnectorSchemaVersion.
func (_c ConnectorSchemaVersion) MarshalText() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorSchemaVersion. %w", _c, err)
	}
	return []byte(_c.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ConnectorSchemaVersion.
func (_c *ConnectorSchemaVersion) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("ConnectorSchemaVersion cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorSchemaVersionFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorSchemaVersion", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for ConnectorSchemaVersion.
func (_c ConnectorSchemaVersion) MarshalYAML() (interface{}, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorSchemaVersion. %w", _c, err)
	}
	return _c.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for ConnectorSchemaVersion.
func (_c *ConnectorSchemaVersion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	if err := unmarshal(&str); err != nil {
		return err
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorSchemaVersion cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorSchemaVersionFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorSchemaVersion", str)
	}
	return nil
}

// Values returns a slice of all String values of the enum.
func (ConnectorSchemaVersion) Values() []string {
	return ConnectorSchemaVersionStrings()
}

const (
	_ConnectorTypeString      = "branchbooleannormalloop"
	_ConnectorTypeLowerString = "branchbooleannormalloop"
)

var (
	_ConnectorTypeValues  = [4]ConnectorType{0, 1, 2, 3}
	_ConnectorTypeStrings = [4]string{_ConnectorTypeString[0:6], _ConnectorTypeString[6:13], _ConnectorTypeString[13:19], _ConnectorTypeString[19:23]}
)

// _ConnectorTypeNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of ConnectorType.
func _ConnectorTypeNoOp() {
	var x [1]struct{}
	_ = x[Branch-(0)]
	_ = x[Boolean-(1)]
	_ = x[Normal-(2)]
	_ = x[Loop-(3)]
}

// ConnectorTypeValues returns all values of the enum.
func ConnectorTypeValues() []ConnectorType {
	cp := _ConnectorTypeValues
	return cp[:]
}

// ConnectorTypeStrings returns a slice of all String values of the enum.
func ConnectorTypeStrings() []string {
	cp := _ConnectorTypeStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_c ConnectorType) IsValid() bool {
	return _c >= 0 && _c <= 3
}

// Validate whether the value is within the range of enum values.
func (_c ConnectorType) Validate() error {
	if !_c.IsValid() {
		return fmt.Errorf("ConnectorType(%d) is %w", _c, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern ConnectorType(%d) instead.
func (_c ConnectorType) String() string {
	if !_c.IsValid() {
		return fmt.Sprintf("ConnectorType(%d)", _c)
	}
	idx := uint(_c)
	return _ConnectorTypeStrings[idx]
}

var (
	_ConnectorTypeStringToValueMap = map[string]ConnectorType{
		_ConnectorTypeString[0:6]:   Branch,
		_ConnectorTypeString[6:13]:  Boolean,
		_ConnectorTypeString[13:19]: Normal,
		_ConnectorTypeString[19:23]: Loop,
	}
	_ConnectorTypeLowerStringToValueMap = map[string]ConnectorType{
		_ConnectorTypeLowerString[0:6]:   Branch,
		_ConnectorTypeLowerString[6:13]:  Boolean,
		_ConnectorTypeLowerString[13:19]: Normal,
		_ConnectorTypeLowerString[19:23]: Loop,
	}
)

// ConnectorTypeFromString determines the enum value with an exact case match.
func ConnectorTypeFromString(raw string) (ConnectorType, bool) {
	v, ok := _ConnectorTypeStringToValueMap[raw]
	if !ok {
		return ConnectorType(0), false
	}
	return v, true
}

// ConnectorTypeFromStringIgnoreCase determines the enum value with a case-insensitive match.
func ConnectorTypeFromStringIgnoreCase(raw string) (ConnectorType, bool) {
	v, ok := ConnectorTypeFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _ConnectorTypeLowerStringToValueMap[raw]
	if !ok {
		return ConnectorType(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for ConnectorType.
func (_c ConnectorType) MarshalBinary() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorType. %w", _c, err)
	}
	return []byte(_c.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for ConnectorType.
func (_c *ConnectorType) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("ConnectorType cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorType", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for ConnectorType.
func (_c ConnectorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_c.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for ConnectorType.
func (_c *ConnectorType) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of ConnectorType: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorType cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorType", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for ConnectorType.
func (_c ConnectorType) MarshalJSON() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorType. %w", _c, err)
	}
	return json.Marshal(_c.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for ConnectorType.
func (_c *ConnectorType) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("ConnectorType should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorType cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorType", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for ConnectorType.
func (_c ConnectorType) Value() (driver.Value, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as ConnectorType. %w", _c, err)
	}
	return _c.String(), nil
}

// Scan implements the sql/driver.Scanner interface for ConnectorType.
func (_c *ConnectorType) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of ConnectorType: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorType cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorType", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for ConnectorType.
func (_c ConnectorType) MarshalText() ([]byte, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorType. %w", _c, err)
	}
	return []byte(_c.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ConnectorType.
func (_c *ConnectorType) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("ConnectorType cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorType", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for ConnectorType.
func (_c ConnectorType) MarshalYAML() (interface{}, error) {
	if err := _c.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as ConnectorType. %w", _c, err)
	}
	return _c.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for ConnectorType.
func (_c *ConnectorType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	if err := unmarshal(&str); err != nil {
		return err
	}
	if len(str) == 0 {
		return fmt.Errorf("ConnectorType cannot be derived from empty string")
	}

	var ok bool
	*_c, ok = ConnectorTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a ConnectorType", str)
	}
	return nil
}

// Values returns a slice of all String values of the enum.
func (ConnectorType) Values() []string {
	return ConnectorTypeStrings()
}
