// Code generated by "go-enumer (github.com/mvrahden/go-enumer)"; DO NOT EDIT.

package authenums

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strconv"
)

var (
	ErrNoValidEnum = errors.New("not a valid enum")
)

const (
	_AuthHandlerTypeString      = "noneinbuiltcustom"
	_AuthHandlerTypeLowerString = "noneinbuiltcustom"
)

var (
	_AuthHandlerTypeValues  = [3]AuthHandlerType{0, 1, 2}
	_AuthHandlerTypeStrings = [3]string{_AuthHandlerTypeString[0:4], _AuthHandlerTypeString[4:11], _AuthHandlerTypeString[11:17]}
)

// _AuthHandlerTypeNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of AuthHandlerType.
func _AuthHandlerTypeNoOp() {
	var x [1]struct{}
	_ = x[None-(0)]
	_ = x[Inbuilt-(1)]
	_ = x[Custom-(2)]
}

// AuthHandlerTypeValues returns all values of the enum.
func AuthHandlerTypeValues() []AuthHandlerType {
	cp := _AuthHandlerTypeValues
	return cp[:]
}

// AuthHandlerTypeStrings returns a slice of all String values of the enum.
func AuthHandlerTypeStrings() []string {
	cp := _AuthHandlerTypeStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_a AuthHandlerType) IsValid() bool {
	return _a >= 0 && _a <= 2
}

// Validate whether the value is within the range of enum values.
func (_a AuthHandlerType) Validate() error {
	if !_a.IsValid() {
		return fmt.Errorf("AuthHandlerType(%d) is %w", _a, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern AuthHandlerType(%d) instead.
func (_a AuthHandlerType) String() string {
	if !_a.IsValid() {
		return fmt.Sprintf("AuthHandlerType(%d)", _a)
	}
	idx := uint(_a)
	return _AuthHandlerTypeStrings[idx]
}

var (
	_AuthHandlerTypeStringToValueMap = map[string]AuthHandlerType{
		_AuthHandlerTypeString[0:4]:   None,
		_AuthHandlerTypeString[4:11]:  Inbuilt,
		_AuthHandlerTypeString[11:17]: Custom,
	}
	_AuthHandlerTypeLowerStringToValueMap = map[string]AuthHandlerType{
		_AuthHandlerTypeLowerString[0:4]:   None,
		_AuthHandlerTypeLowerString[4:11]:  Inbuilt,
		_AuthHandlerTypeLowerString[11:17]: Custom,
	}
)

// AuthHandlerTypeFromString determines the enum value with an exact case match.
func AuthHandlerTypeFromString(raw string) (AuthHandlerType, bool) {
	v, ok := _AuthHandlerTypeStringToValueMap[raw]
	if !ok {
		return AuthHandlerType(0), false
	}
	return v, true
}

// AuthHandlerTypeFromStringIgnoreCase determines the enum value with a case-insensitive match.
func AuthHandlerTypeFromStringIgnoreCase(raw string) (AuthHandlerType, bool) {
	v, ok := AuthHandlerTypeFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _AuthHandlerTypeLowerStringToValueMap[raw]
	if !ok {
		return AuthHandlerType(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for AuthHandlerType.
func (_a AuthHandlerType) MarshalBinary() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthHandlerType. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for AuthHandlerType.
func (_a *AuthHandlerType) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("AuthHandlerType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthHandlerTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthHandlerType", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for AuthHandlerType.
func (_a AuthHandlerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_a.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for AuthHandlerType.
func (_a *AuthHandlerType) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of AuthHandlerType: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthHandlerType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthHandlerTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthHandlerType", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for AuthHandlerType.
func (_a AuthHandlerType) MarshalJSON() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthHandlerType. %w", _a, err)
	}
	return json.Marshal(_a.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for AuthHandlerType.
func (_a *AuthHandlerType) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("AuthHandlerType should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthHandlerType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthHandlerTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthHandlerType", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for AuthHandlerType.
func (_a AuthHandlerType) Value() (driver.Value, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as AuthHandlerType. %w", _a, err)
	}
	return _a.String(), nil
}

// Scan implements the sql/driver.Scanner interface for AuthHandlerType.
func (_a *AuthHandlerType) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of AuthHandlerType: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthHandlerType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthHandlerTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthHandlerType", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for AuthHandlerType.
func (_a AuthHandlerType) MarshalText() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthHandlerType. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for AuthHandlerType.
func (_a *AuthHandlerType) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("AuthHandlerType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthHandlerTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthHandlerType", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for AuthHandlerType.
func (_a AuthHandlerType) MarshalYAML() (interface{}, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthHandlerType. %w", _a, err)
	}
	return _a.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for AuthHandlerType.
func (_a *AuthHandlerType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	if err := unmarshal(&str); err != nil {
		return err
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthHandlerType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthHandlerTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthHandlerType", str)
	}
	return nil
}

// Values returns a slice of all String values of the enum.
func (AuthHandlerType) Values() []string {
	return AuthHandlerTypeStrings()
}

const (
	_AuthTokenStyleString      = "headerquery-paramscookie"
	_AuthTokenStyleLowerString = "headerquery-paramscookie"
)

var (
	_AuthTokenStyleValues  = [3]AuthTokenStyle{0, 1, 2}
	_AuthTokenStyleStrings = [3]string{_AuthTokenStyleString[0:6], _AuthTokenStyleString[6:18], _AuthTokenStyleString[18:24]}
)

// _AuthTokenStyleNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of AuthTokenStyle.
func _AuthTokenStyleNoOp() {
	var x [1]struct{}
	_ = x[Header-(0)]
	_ = x[QueryParams-(1)]
	_ = x[Cookie-(2)]
}

// AuthTokenStyleValues returns all values of the enum.
func AuthTokenStyleValues() []AuthTokenStyle {
	cp := _AuthTokenStyleValues
	return cp[:]
}

// AuthTokenStyleStrings returns a slice of all String values of the enum.
func AuthTokenStyleStrings() []string {
	cp := _AuthTokenStyleStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_a AuthTokenStyle) IsValid() bool {
	return _a >= 0 && _a <= 2
}

// Validate whether the value is within the range of enum values.
func (_a AuthTokenStyle) Validate() error {
	if !_a.IsValid() {
		return fmt.Errorf("AuthTokenStyle(%d) is %w", _a, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern AuthTokenStyle(%d) instead.
func (_a AuthTokenStyle) String() string {
	if !_a.IsValid() {
		return fmt.Sprintf("AuthTokenStyle(%d)", _a)
	}
	idx := uint(_a)
	return _AuthTokenStyleStrings[idx]
}

var (
	_AuthTokenStyleStringToValueMap = map[string]AuthTokenStyle{
		_AuthTokenStyleString[0:6]:   Header,
		_AuthTokenStyleString[6:18]:  QueryParams,
		_AuthTokenStyleString[18:24]: Cookie,
	}
	_AuthTokenStyleLowerStringToValueMap = map[string]AuthTokenStyle{
		_AuthTokenStyleLowerString[0:6]:   Header,
		_AuthTokenStyleLowerString[6:18]:  QueryParams,
		_AuthTokenStyleLowerString[18:24]: Cookie,
	}
)

// AuthTokenStyleFromString determines the enum value with an exact case match.
func AuthTokenStyleFromString(raw string) (AuthTokenStyle, bool) {
	v, ok := _AuthTokenStyleStringToValueMap[raw]
	if !ok {
		return AuthTokenStyle(0), false
	}
	return v, true
}

// AuthTokenStyleFromStringIgnoreCase determines the enum value with a case-insensitive match.
func AuthTokenStyleFromStringIgnoreCase(raw string) (AuthTokenStyle, bool) {
	v, ok := AuthTokenStyleFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _AuthTokenStyleLowerStringToValueMap[raw]
	if !ok {
		return AuthTokenStyle(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for AuthTokenStyle.
func (_a AuthTokenStyle) MarshalBinary() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthTokenStyle. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for AuthTokenStyle.
func (_a *AuthTokenStyle) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("AuthTokenStyle cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTokenStyleFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthTokenStyle", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for AuthTokenStyle.
func (_a AuthTokenStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_a.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for AuthTokenStyle.
func (_a *AuthTokenStyle) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of AuthTokenStyle: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthTokenStyle cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTokenStyleFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthTokenStyle", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for AuthTokenStyle.
func (_a AuthTokenStyle) MarshalJSON() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthTokenStyle. %w", _a, err)
	}
	return json.Marshal(_a.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for AuthTokenStyle.
func (_a *AuthTokenStyle) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("AuthTokenStyle should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthTokenStyle cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTokenStyleFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthTokenStyle", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for AuthTokenStyle.
func (_a AuthTokenStyle) Value() (driver.Value, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as AuthTokenStyle. %w", _a, err)
	}
	return _a.String(), nil
}

// Scan implements the sql/driver.Scanner interface for AuthTokenStyle.
func (_a *AuthTokenStyle) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of AuthTokenStyle: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthTokenStyle cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTokenStyleFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthTokenStyle", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for AuthTokenStyle.
func (_a AuthTokenStyle) MarshalText() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthTokenStyle. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for AuthTokenStyle.
func (_a *AuthTokenStyle) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("AuthTokenStyle cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTokenStyleFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthTokenStyle", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for AuthTokenStyle.
func (_a AuthTokenStyle) MarshalYAML() (interface{}, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthTokenStyle. %w", _a, err)
	}
	return _a.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for AuthTokenStyle.
func (_a *AuthTokenStyle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	if err := unmarshal(&str); err != nil {
		return err
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthTokenStyle cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTokenStyleFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthTokenStyle", str)
	}
	return nil
}

// Values returns a slice of all String values of the enum.
func (AuthTokenStyle) Values() []string {
	return AuthTokenStyleStrings()
}

const (
	_AuthTypeString      = "basicdigesto-authapi-keybearer-token"
	_AuthTypeLowerString = "basicdigesto-authapi-keybearer-token"
)

var (
	_AuthTypeValues  = [5]AuthType{0, 1, 2, 3, 4}
	_AuthTypeStrings = [5]string{_AuthTypeString[0:5], _AuthTypeString[5:11], _AuthTypeString[11:17], _AuthTypeString[17:24], _AuthTypeString[24:36]}
)

// _AuthTypeNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of AuthType.
func _AuthTypeNoOp() {
	var x [1]struct{}
	_ = x[Basic-(0)]
	_ = x[Digest-(1)]
	_ = x[OAuth-(2)]
	_ = x[ApiKey-(3)]
	_ = x[BearerToken-(4)]
}

// AuthTypeValues returns all values of the enum.
func AuthTypeValues() []AuthType {
	cp := _AuthTypeValues
	return cp[:]
}

// AuthTypeStrings returns a slice of all String values of the enum.
func AuthTypeStrings() []string {
	cp := _AuthTypeStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_a AuthType) IsValid() bool {
	return _a >= 0 && _a <= 4
}

// Validate whether the value is within the range of enum values.
func (_a AuthType) Validate() error {
	if !_a.IsValid() {
		return fmt.Errorf("AuthType(%d) is %w", _a, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern AuthType(%d) instead.
func (_a AuthType) String() string {
	if !_a.IsValid() {
		return fmt.Sprintf("AuthType(%d)", _a)
	}
	idx := uint(_a)
	return _AuthTypeStrings[idx]
}

var (
	_AuthTypeStringToValueMap = map[string]AuthType{
		_AuthTypeString[0:5]:   Basic,
		_AuthTypeString[5:11]:  Digest,
		_AuthTypeString[11:17]: OAuth,
		_AuthTypeString[17:24]: ApiKey,
		_AuthTypeString[24:36]: BearerToken,
	}
	_AuthTypeLowerStringToValueMap = map[string]AuthType{
		_AuthTypeLowerString[0:5]:   Basic,
		_AuthTypeLowerString[5:11]:  Digest,
		_AuthTypeLowerString[11:17]: OAuth,
		_AuthTypeLowerString[17:24]: ApiKey,
		_AuthTypeLowerString[24:36]: BearerToken,
	}
)

// AuthTypeFromString determines the enum value with an exact case match.
func AuthTypeFromString(raw string) (AuthType, bool) {
	v, ok := _AuthTypeStringToValueMap[raw]
	if !ok {
		return AuthType(0), false
	}
	return v, true
}

// AuthTypeFromStringIgnoreCase determines the enum value with a case-insensitive match.
func AuthTypeFromStringIgnoreCase(raw string) (AuthType, bool) {
	v, ok := AuthTypeFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _AuthTypeLowerStringToValueMap[raw]
	if !ok {
		return AuthType(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for AuthType.
func (_a AuthType) MarshalBinary() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthType. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for AuthType.
func (_a *AuthType) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("AuthType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthType", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for AuthType.
func (_a AuthType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_a.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for AuthType.
func (_a *AuthType) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of AuthType: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthType", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for AuthType.
func (_a AuthType) MarshalJSON() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthType. %w", _a, err)
	}
	return json.Marshal(_a.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for AuthType.
func (_a *AuthType) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("AuthType should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthType", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for AuthType.
func (_a AuthType) Value() (driver.Value, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as AuthType. %w", _a, err)
	}
	return _a.String(), nil
}

// Scan implements the sql/driver.Scanner interface for AuthType.
func (_a *AuthType) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of AuthType: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthType", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for AuthType.
func (_a AuthType) MarshalText() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthType. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for AuthType.
func (_a *AuthType) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("AuthType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthType", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for AuthType.
func (_a AuthType) MarshalYAML() (interface{}, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as AuthType. %w", _a, err)
	}
	return _a.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for AuthType.
func (_a *AuthType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	if err := unmarshal(&str); err != nil {
		return err
	}
	if len(str) == 0 {
		return fmt.Errorf("AuthType cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AuthTypeFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a AuthType", str)
	}
	return nil
}

// Values returns a slice of all String values of the enum.
func (AuthType) Values() []string {
	return AuthTypeStrings()
}
